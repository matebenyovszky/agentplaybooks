#!/usr/bin/env node

/**
 * Generates known blog slugs and lightweight blog metadata index from public/blog.
 * This runs at build time to avoid runtime filesystem dependency for listing posts.
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const blogDir = path.join(__dirname, '..', 'public', 'blog');
const outputFile = path.join(__dirname, '..', 'src', 'lib', 'blog-slugs.generated.ts');

type BlogMeta = {
  title: string;
  description: string;
  date: string;
  author?: string;
};

function parseFrontmatter(fileContent: string): { metadata: Record<string, string> } {
  const frontmatterRegex = /^---\n([\s\S]*?)\n---\n([\s\S]*)$/;
  const match = fileContent.match(frontmatterRegex);

  if (!match) {
    return { metadata: {} };
  }

  const frontmatterBlock = match[1];
  const metadata: Record<string, string> = {};

  frontmatterBlock.split('\n').forEach((line) => {
    const [key, ...valueParts] = line.split(':');
    if (key && valueParts.length > 0) {
      metadata[key.trim()] = valueParts.join(':').trim().replace(/^['\"](.*)['\"]+$/, '$1');
    }
  });

  return { metadata };
}

function slugFromFile(file: string): string {
  let slug = file.replace(/\.md$/, '');
  const parts = slug.split('.');
  if (parts.length > 1 && parts[parts.length - 1].length === 2) {
    parts.pop();
    slug = parts.join('.');
  }
  return slug;
}

function generateBlogData() {
  if (!fs.existsSync(blogDir)) {
    console.warn('Blog directory not found, creating empty slug list');
    return { slugs: [] as string[], index: {} as Record<string, BlogMeta> };
  }

  const files = fs.readdirSync(blogDir);
  const slugSet = new Set<string>();
  const index: Record<string, BlogMeta> = {};

  files.forEach((file) => {
    if (!file.endsWith('.md')) return;
    const slug = slugFromFile(file);
    slugSet.add(slug);

    // Prefer canonical default markdown (slug.md) for list metadata.
    if (file !== `${slug}.md`) {
      return;
    }

    const filePath = path.join(blogDir, file);
    const content = fs.readFileSync(filePath, 'utf-8');
    const { metadata } = parseFrontmatter(content);
    index[slug] = {
      title: metadata.title || slug,
      description: metadata.description || '',
      date: metadata.date || new Date().toISOString(),
      author: metadata.author,
    };
  });

  const slugs = Array.from(slugSet).sort();

  // Backfill metadata for slugs that only have localized files.
  slugs.forEach((slug) => {
    if (!index[slug]) {
      index[slug] = {
        title: slug,
        description: '',
        date: new Date().toISOString(),
      };
    }
  });

  return { slugs, index };
}

function writeSlugFile(slugs: string[], index: Record<string, BlogMeta>) {
  const content = `// Auto-generated file - do not edit manually
// Generated by scripts/generate-blog-slugs.ts

/**
 * List of all known blog post slugs.
 * This file is automatically generated at build time.
 */
export const knownBlogSlugs = ${JSON.stringify(slugs, null, 2)} as const;

export type GeneratedBlogMeta = {
  title: string;
  description: string;
  date: string;
  author?: string;
};

/**
 * Build-time metadata index for blog listing.
 */
export const generatedBlogIndex: Record<string, GeneratedBlogMeta> = ${JSON.stringify(index, null, 2)};

export function getKnownBlogSlugs(): string[] {
  return [...knownBlogSlugs];
}
`;

  fs.writeFileSync(outputFile, content, 'utf-8');
}

try {
  console.log('üîç Scanning blog directory...');
  const { slugs, index } = generateBlogData();

  console.log(`üìù Found ${slugs.length} blog post(s):`);
  slugs.forEach((slug) => console.log(`   - ${slug}`));

  writeSlugFile(slugs, index);
  console.log(`‚úÖ Generated: ${path.relative(process.cwd(), outputFile)}`);
} catch (error) {
  console.error('‚ùå Error generating blog slugs:', error);
  process.exit(1);
}
